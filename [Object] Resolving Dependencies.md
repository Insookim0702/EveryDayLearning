### 책 : [Object] 
#### 오늘의 주제 : 의존성 해결하기
#### 날짜 : 2019-07-17
#### 학습시간 : 22:00 ~ 23:51

### 오늘 꼭 알아야 하는 내용.
#### 1. 컨파일타임은 코드 그 자체의 타임, 런타임은 실제 실행시간
#### 2. 의존성 해결은 컴파일타임에 정해진 여러방법 중에 런타임에서 어느 한 방법을 선택하여 실행할 수 있게 하는 것을 말한다.
#### 2. 의존성 해결방법 3가지
  1) 생성자에 인자로 인스턴스를 정해준다.
  2) setter 메서드로 협력 객체의 인스턴스를 정해준다.
  3) 메서드 인자로 인스턴스를 정해준다.
#### 3. 의존성은 존재의 유무, 결합도는 정도의 차이이다. 의존성과 결합도는 다르다.
#### 4. 의존성을 퍼블릭 인터페이스에 명시해야한다.
#### 5. 명시적인 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.


___
## 공부한 내용
> ### 런타임 의존성과 컴파일 타임 의존성
> 런타임은 애플리케이션이 실행되는 시점을 말한다. 컴파일은 코드 그 자체를 말한다. 코드에 
> ```
> public class Movie{
>     public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy){
>     this.discountPolicy =discountPolicy;
> }
> ```
> 다음 코드를 보면 코드가 명시된 시점이 컴파일시점인거다.(p.261)


> 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다. 이것이 **의존성 해결**이라고 한다. 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체해야 하는 것을 **의존성 해결**이라고 부른다. 의존성을 해결하기 위해서는 일반적으로 다음과 같이 세 가지 방법을 사용한다.(p.261)
> * 객체를 생성하는 시점에 **생성자**를 통해 의존성 해결
> * 객체 생성 후 **setter 메서드**를 통해 의존성 해결
> * 메서드 실행 시 **인자**를 이용해 의존성 해결
>  예를 들어, 어떤 영화의 요금 계산에 금액 할인 정책을 적용하고 싶다고 가정하면, Movie 객체를 생성할 때 AmountDiscountPolicy의 인스턴스를 Movie의 생성자에 인자로 전달하면 된다.
>  
> 예를 들어, 어떤 영화의 요금 계산에 금액 할인 정책을 적용하고 싶다고 가정하면, Movie 객체를 생성할 때 AmountDiscountPolicy의 인스턴스를 Movie의 생성자에 **인자**로 전달하면 된다.
>  ```
>  Movie JohnWick = new Movie("존윅",
>                             Duration.ofMinutes(149),
>                             Money.wons(10000),
>                             **new AmountDiscountPolicy(...))**;
>  ```
>  아니면
>  Movie 클래스에 DiscountPolicy를 설정할 수 있는 setter메서드를 정의하고,
>  ```
>  public class Movie{
>        public void setDiscountPolicy(DiscountPolicy discountPolicy){
>              this.discountPolicy= discountPolicy;
>        }
>  }
>  ```
>  Movie의 인스턴스를 생성하고 메서드를 이용해서 의존성을 해결하는 방법도 있다.
> ```
> Movie = new Movie(...);
> JohnWick.setDiscountPolicy(new AmountDiscountPolicy(...));
> ```

> ### 의존성과 결합도는 다르다(p.266)
> * 의존성 : 의존성이 있다. 의존성이 없다.
> * 결합도  : 결합도가 강하다. 결합도가 약하다.

> 결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다. 한 요소가 다른 요소에 대해 더 많은 정보를 알고 있을수록 두 요소는 강하게 결합된다. 반대로 한 요소가 다른 요소에 대해 더 적은 정보를 알고 있을수록 두 요소는 약하게 결합된다. 결합도를 느슨하게 하기 위해서는 협력하는 객체의 정보를 최대한 적게 알아야 한다. 이를 위한 것이 **추상화**이다.(p.267)


> ### 아래로 갈수록 클라이언트가 알아야 하는 지식의 양이 적어진다. 그래서 결합도가 느슨해 진다.
> * 구체 클래스 의존성(concrete class dependency)
> * 추상 클래스 의존성(abstract class dependency)
> * 인터페이스 의존성(interface dependency)
> 
> 인터페이스에 의존하면 상속 계층을 모르더라도 협력이 가능해진다.인터페이스 의존성은 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만을 남기기 때문에 추상 클래스 의존성보다 결합도가 낮다. 추상 클래스 의존성은 협력하는 대상이 속한 클래싀의 상속 계층이 무엇인지에 대해서는 알고 있어야 한다.


> 의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 안에서 직접 생성하는 방법 사이의 가장 큰 차이점은 퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는지 여부다. 생성자의 인자로 선언하는 방법은 Movie가 DiscountPolicy에 의존한다는 사실을 Movie의 퍼블릭 인터페이스에 드러내는 것이다. 이것은 setter 메서드를 사용하는 방식과 메서드 인자를 사용하는 방식과 동일하다. 모든 경우에 의존성은 명시적으로 퍼블릭 인터페이스에 노출된다. 이를 명시적인 의존성(explicit dependency)라고 한다. 반면 Movie의 내부에서 AmountDiscountPolicy의 인스턴스를 직접 생성하는 방식은 Movie가 DiscountPolicy에 의존한다는 사실을 감춘다.(p. 270)


>의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 봐야한다. 또한 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구조를 직접 변경해야 한다.

> 명시적인 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.
